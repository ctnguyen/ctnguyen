\documentclass{book}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{lmodern}
\usepackage[a4paper]{geometry}
\usepackage[frenchb]{babel}
\usepackage{graphicx}
\usepackage{hyperref}

\usepackage{pstricks}
\usepackage{pst-node}
\usepackage{wrapfig}

\usepackage{listings}
\lstset{language=C,basicstyle=\scriptsize\color{green},identifierstyle=\color{orange},keywordstyle=\color{blue}}

\usepackage{amsmath}
\usepackage{amssymb}
\bibliographystyle{plain}

\begin{document}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%=======================================================================================%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{titlepage}
%%%%%%%%%%%%%%%%%%%%%%%%%%  LOGO  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 \begin{pspicture}(-5,4)(5,5)
%\rput(-5,3){\href{http://www.upmc.fr/FR/info/00}{\includegraphics[scale=1.0]{upmc_logo}}}
\rput(-4,6.5){\includegraphics[scale=1.0]{upmc_logo}}
\rput(-4,5){\resizebox{6cm}{0.3cm}{\begin{tabular}{l}
		Universit√© de Pierre et Marie CURIE (PARIS VI) \\
		4 Place Jussieu 75005 Paris
            \end{tabular}}}
%\psline(-5,0)(5,0)
\end{pspicture}
%%%%%%%%%%%%%%%%%%%%%%%%%%  LOGO  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%  Titre %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{center}
\resizebox{14cm}{1cm}{\bsc{√âcoulement laminaire dans une conduite}}\\ 
\large\bsc{√©quation de Navier-Stokes stationnaire}\\
\large\textbf{Enseign√© par M.Fr√©d√©ric Hecht}
\end{center}
%%%%%%%%%%%%%%%%%%%%%%%%%%  Titre  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%  image maillage %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{pspicture}(-7,-2)(7,2)
\psline[linecolor=blue](5,1)(-5,1)%Label = 2
\rput(0,1.25){\Rnode{C}{\small{\color{blue}label=2}}}
\psline[linecolor=red](-5,1)(-5,0)%Label = 1
\rput(-5,1.25){\small $\beta$} \rput(-5,-0.25){\small $\alpha$}
\rput{90}(-5.25,0.5){\Rnode{D}{\small{\color{red}label=1}}}
\psline[linecolor=blue](-5,0)(-3,0)(-3,-1)(5,-1)%Label = 2
\rput(0,-1.25){\Rnode{E}{\small{\color{blue}label=2}}}
\pscurve[linecolor=green](5,-1)(4.75,-0.5)(5.1,0)(4.5,0.5)(5,1)%Label = 3
\rput{-90}(5.5,0){\Rnode{F}{\small{\color{green}label=3}}}


\pscurve[linecolor=red](-5,0)(-4,0.5)(-5,1)%Label = 3
\rput(-4.75,0.75){\Rnode{A}{}}
\rput(-6,1.9){\Rnode{B}{\color{red}\small 4*(y-$\alpha$)*($\beta$-y)}}
\ncline{->}{A}{B}

%\psline(-7,-2)(7,2)
\end{pspicture}
%%%%%%%%%%%%%%%%%%%%%%%%%%  image maillage %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%  Auteur %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{flushright}
\underline{\textbf {NGUYEN Chi Thanh}} \\
{\textbf {2008-2009}}
\end{flushright}
%%%%%%%%%%%%%%%%%%%%%%%%%%  Auteur %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{center}
\begin{pspicture}(-7,-4)(7,4)
\rput(-3,-5){\includegraphics[scale=0.5]{ImageTitle}}
\rput(4.7,3){\begin{tabular}{l}
		$\bullet$  \texttt{Existence et unicit√©} \\
		$\bullet$  \texttt{M√©thode de continuation} \\
		$\bullet$  \texttt{Programmation C++} \\
		$\bullet$  \texttt{Qt Programmation GUI} 	
               \end{tabular}}
%\psline(-7,-4)(7,7)
\end{pspicture}
\end{center}

\end{titlepage}
\tableofcontents
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%=======================================================================================%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter*{Introduction}
Dans le cadre des √©tudes de Master 2 de math√©matique de la mod√©lisation (ANEDP) √  l'universit√© Pierre et Marie Curie, les √©tudiants suivant le module NM406 (R√©solution des EDP par la M√©thode des √âl√©m√©nts Finis) enseign√© par \href{http://www.ann.jussieu.fr/~hecht/}{M.Fr√©d√©ric Hecht} doivent r√©aliser un projet de calcul scienfique utilisant la FEM d√©velopp√© en C++.Ce projet est bas√© sur la biblioth√®que servant √  d√©velopper le logiciel \href{http://www.freefem.org/ff++/}{FreeFem++} par le professeur.  

\paragraph{Ph√©nom√®ne physique : }Le projet consiste √  simuler l'√©coulement laminaire dans une conduite en r√©solvant l'√©quation de Navier-Stokes stationnaire. Un √©coulement laminaire est r√©gulier (il ne pr√©sente pas trop de variations spatiales ou temporelles), bien souvent stationnaire.  La viscosit√© stabilise et r√©gularise les √©coulements de fa√ßon g√©n√©rale. Un fluide pr√©sentant une viscosit√© importante s'√©coulera de fa√ßon laminaire. Un √©coulement est caract√©ris√© par son nombre de Reynolds, qui permet de se faire une id√©e de sa stabilit√© : quand ce nombre est petit, l'√©coulement est laminaire, quand il est grand, l'√©coulement est en g√©n√©rale instable et turbulent. La transition entre les √©coulements stables et instable voire turbulents est un sujet d'√©tude important. Dans une conduite, on consid√®re souvent que la transition peut se produire entre 2000 et 3000.

\paragraph{Probl√®me math√©matique :}Il s'agit en fait d'une solution stable des √©quations de Navier-Stokes, au sens o√π si on modifie l'√©coulement, il retourne vers la solution laminaire. Le domaine √©tudi√© ici est l'un des probl√®me classique : la marche descendante. 
\begin{center}
 \begin{pspicture}(-7,-1.5)(7,1.5)
 \psline[linecolor=blue](5,1)(-5,1)
 \psline[linecolor=red](-5,1)(-5,0)
 \rput(-5.25,0.5){\color{red}$\Gamma$}
 \psline[linecolor=blue](-5,0)(-3,0)(-3,-1)(5,-1)
 \pscurve[linecolor=green](5,-1)(4.75,-0.5)(5.1,0)(4.5,0.5)(5,1)
 \pscurve[linecolor=red](-5,0)(-4,0.5)(-5,1)

 %\psline(-7,-1.5)(7,1.5)
 \end{pspicture}
\end{center}
La conduite horizontale, la rentr√©e du fluid √  droite avec le profit parabolique repr√©santant la condition Poiseuille donnant le probl√®me math√©matique suivant :
\[
(\wp)\hspace{0.25cm}\left\{
\begin{array}{rl}
(\textbf{u}.\triangledown) \textbf{u} -\nu \bigtriangleup \textbf{u} + \triangledown p & =0 \\
\triangledown \textbf{u} & =0 \\
\textbf{u}_\Gamma &=g 
\end{array}\right.
\]
Ayanat pour but de r√©soudre ce probl√®me,le projet se compose donc l'√©tude math√©matique (existence et l'unicit√© de solution, l'impl√©mentation num√©rique), et l'√©tude informatique bas√© sur la programmation C++ pour r√©soudre ce probl√®me.  
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%=======================================================================================%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{√âtudes math√©matiques}
Cause de la limite du temps l'√©tude du cadre fonctionnelle ne sera pas toute d√©taill√©e dans ce projet. Ce rapport ne pr√©sente qu'une partie bri√®ve de l'√©tude fonctionnelle de l'√©quation Navier-Stokes dans ce cas concret pour arriver √  l'impl√©mentation informatique, qui est l'essentiel de l'exercice. Pour plus de d√©tails sur la m√©thode de continuation, il est de pr√©f√©rence de consulter \cite[Girault-Raviart p.297-365]{NCT1} 
\section{Cadre fonctionnelle}
Ce paragraphe montre bri√®vement la m√©thode de continuation servant d'une part √  prouver l'existence et l'unicit√© de la solution, d'autre amener √  l'impl√©mentation du sch√©ma num√©rique de type Newton. 
\paragraph{M√©thode de continuation :} Cette m√©thode, par la construction d'une fonctionnelle $F$ d'un certain d'espace de d√©part et d'espace d'arriv√© :
\[
\begin{array}{rl}
 \Lambda \times X &\longmapsto \chi \\
 (\lambda,u) &\longmapsto F(\lambda,u)
\end{array}
\]
on peut prouver que la r√©solution du probl√®me : 
\begin{equation}\label{Pcontinuation}
 F(\lambda,u)=0
\end{equation}
est √©quivalent au probl√®me : 
\begin{equation}\label{Pnavierstokes}
(\wp)\hspace{0.25cm}\left\{
\begin{array}{rl}
(\textbf{u}.\triangledown) \textbf{u} -\nu \bigtriangleup \textbf{u} + \triangledown p & =0 \\
\triangledown \textbf{u} & =0 \\
\textbf{u}_\Gamma &=g 
\end{array}\right.
\end{equation}
Pour comprendre ce m√©canisme, on a besoin de quelques d√©finitions des espaces fonctionnelles et ses op√©rateurs :
\paragraph{Espaces fonctionnels :}
\[
\begin{array}{rl}
  I & \subset \Re \\
  X & =H^1(\Omega)^N \times L^2_0(\Omega)\\
  Y & =H^{-1}(\Omega)^N \times \{ g \in H^{\frac{1}{2}}(\Gamma)^N, \int_{\partial\Omega}g.nd\sigma=0 \}
\end{array}
\]
\paragraph{Op√©rateur de Stokes :}
Soit le probl√®me de Stokes :
\[
\left\{
\begin{array}{rl}
(-\nu \bigtriangleup \textbf{u} + \triangledown p & =f \\
\triangledown \textbf{u} & =0 \\
\textbf{u}_\Gamma &=g 
\end{array}\right.
\]
On peut d√©montrer l'existence et l'unicit√© de ce probl√®me dans $X$. De sorte que l'on peut d√©finir un isomorphisme :
\[T : 
\begin{array}{rl}
Y &\longmapsto X \\
 \left[\begin{array}{ll}f\\g\end{array}\right] &\longmapsto \left[\begin{array}{ll}u\\p\end{array}\right]
\end{array}
\]
Remarque : T est lin√©aire, continue donc diff√©rentialble.
\paragraph{Op√©rateur auxiliaire :}
On d√©finit encore un autre op√©rateur :
\[G : 
\begin{array}{rl}
I \times X &\longmapsto Y \\
 ( \lambda, \left[\begin{array}{ll}v\\q\end{array}\right] ) &\longmapsto -\left[\begin{array}{cc}\lambda(f-(v.\triangledown)v)\\g\end{array}\right]
\end{array}
\]
On peut remarquer encore que l'application partielle $G(\lambda,.)$ est lin√©aire continue, donc il est facile √  calculer sa diff√©rentielle. 
\paragraph{Op√©rateur de continuation :}
On s'am√®ne finalement √  d√©finir l'op√©rateur $F=Id +T \circ G$, c'est √  dire :
\[F : 
\begin{array}{rl}
I \times X &\longmapsto X \\
 ( \lambda, \left[\begin{array}{ll}u\\p\end{array}\right] ) &\longmapsto 
 F( \lambda, \left[\begin{array}{ll}u\\p\end{array}\right] )
 =Id\left[\begin{array}{ll}u\\p\end{array}\right] 
 +T\circ G ( \lambda, \left[\begin{array}{ll}u\\p\end{array}\right] ) 
\end{array}
\]
De sorte que comme G, $F(\lambda,.)$ est une application lin√©aire continue de $X$ √  $Y$, que l'on peut calculer facilement la diff√©rentielle de cettet application partielle : 
\[F(\lambda,\bullet) : 
\begin{array}{rl}
 X &\longmapsto X \\
 \left[\begin{array}{ll}u\\p\end{array}\right] &\longmapsto 
 Id\left[\begin{array}{ll}u\\p\end{array}\right] 
 +T\circ G ( \lambda, \left[\begin{array}{ll}u\\p\end{array}\right] ) 
\end{array}
\]
Partant de ces principales constructions d'espaces et op√©rateurs, en utilisant ensuite la th√©orie des fonctions implicites, on se ram√®ne √  prouver l'√©quivalent des probl√®me ~\eqref{Pcontinuation} et ~\eqref{Pnavierstokes}. L'√©tude fonctionnelle prouve que $\left[\begin{array}{ll}u\\p\end{array}\right]$ de $X$ est solution du probl√®me ~\eqref{Pnavierstokes} si et seulement si $\left[\begin{array}{ll}u\\ \frac{p}{\nu}\end{array}\right]$ de $X$ est solution du probl√®me $F(\frac{1}{\nu},\bullet)=0$.
\section{Cadre num√©rique}
Issu de la conclution de la derni√®re section, on peut utiliser le sch√©ma de Newton pour r√©soudre le probl√®me $F(\frac{1}{\nu},\bullet)=0$. Soit $\left[\begin{array}{ll}u\\ \frac{p}{\nu}\end{array}\right]$ solution, par le th√©or√®me d'inversion local, on a :
\[
F(\lambda,\left[\begin{array}{ll}u\\ \frac{p}{\nu}\end{array}\right])=0 \Longleftrightarrow
\partial_{up}F_{(u,p)}(\frac{1}{\nu},\bullet) \text{est un isomorphisme}.
\]
Pour la r√©solution num√©rique, on peut utiliser le sch√©ma de Newton :
\[
\left[\begin{array}{ll}u^{n+1}\\ \frac{p^{n+1}}{\nu}\end{array}\right]=
\left[\begin{array}{ll}u^{n}\\ \frac{p^{n}}{\nu}\end{array}\right]-
\partial_{up}F^{-1}_{(u^n,\frac{p^n}{\nu})}(\frac{1}{\nu},\bullet) \circ
F(\frac{1}{\nu},\left[\begin{array}{ll}u^{n}\\ \frac{p^{n}}{\nu}\end{array}\right])
\]
En calculant la diff√©rentielle de $F$ par les diff√©rentielles de $G$ et de $T$, on arrive au :
\paragraph{Sch√©ma de Newton :}
\[
(N)\hspace{0.25cm}\left\{
\begin{array}{rl}
-\bigtriangleup \textbf{u}^{n+1} + \frac{1}{\nu}[( \textbf{u}^n. \triangledown) \textbf{u}^{n+1}+ (\textbf{u}^{n+1} .\triangledown) \textbf{u}^n] + \triangledown p^{n+1} &=\frac{1}{\nu}(\textbf{u}^n.\triangledown)\textbf{u}^n \\
\text{div}\textbf{u}^{n+1}          &=0 \\
\textbf{u}^{n+1}_{|\Gamma_D}  &=g
\end{array}\right.
\]
Partant de ce sch√©mas, en affectant que $\textbf{uold}=\textbf{u}^{n}$ est la solution calcul√©e de l'it√©ration pr√©c√©dante, $\textbf{u}=\textbf{u}^{n+1}$ est la solution √  calculer, on r√©crit pour chaque it√©ration, le probl√®me devient : 
\[
(N)\hspace{0.25cm}\left\{
\begin{array}{rl}
-\bigtriangleup \textbf{u} + \frac{1}{\nu}[( \textbf{uold}. \triangledown) \textbf{u}+ (\textbf{u} .\triangledown) \textbf{uold}] + \triangledown p &=\frac{1}{\nu}(\textbf{uold}.\triangledown)\textbf{uold} \\
\text{div}\textbf{u}          &=0 \\
\textbf{u}_{|\Gamma_D}  &=g
\end{array}\right.
\]
Soit $\left[\begin{array}{cc} \textbf{v}\\ q\end{array}\right]$ dans le m√™me espace, en multipliant et int√©grant, le probl√®me √©quivalent √  la :
\paragraph{Formulation Variationnelle :}
\[
\left\{
\begin{array}{rl}
-\int_{\Omega} \bigtriangleup \textbf{u.v} + 
\frac{1}{\nu}\int_{\Omega} [( \textbf{uold}. \triangledown) \textbf{u}+ (\textbf{u} .\triangledown) \textbf{uold}].\textbf{v}  &\\
+\int_{\Omega} \triangledown p.\textbf{v}
-\int_{\Omega} q\text{div}\textbf{u} &=
\frac{1}{\nu}\int_{\Omega}(\textbf{uold}.\triangledown)\textbf{uold}.\textbf{v} \\
\textbf{u}_{|\Gamma_D}  &=g
\end{array}\right.
\]
En d√©veloppant terme √  terme de la premi√®re √©galit√©, on a :
\[
\begin{array}{rl}

-\int_{\Omega} \bigtriangleup \textbf{u.v} &=\int_{\Omega} \triangledown \textbf{u}.\triangledown \textbf{v}\color{blue}{-\int_{\partial\Omega} \bigtriangleup \textbf{u}.(\textbf{v}.\textbf{n})\text{d}\sigma}\\
 
+\frac{1}{\nu}\int_{\Omega} [( \textbf{uold}. \triangledown) \textbf{u}+ (\textbf{u} .\triangledown) \textbf{uold}].\textbf{v} &=+\frac{1}{\nu}\int_{\Omega} [( \textbf{uold}. \triangledown) \textbf{u}+ (\textbf{u} .\triangledown) \textbf{uold}].\textbf{v} \\

+\int_{\Omega} \triangledown p.\textbf{v} &=-\int_{\Omega} p\text{div}\textbf{v}\color{blue}{+\int_{\partial\Omega} p.(\textbf{v}.\textbf{n})\text{d}\sigma}\\
 
-\int_{\Omega} q\text{div}\textbf{u} &=-\int_{\Omega} q\text{div}\textbf{u}\\

\frac{1}{\nu}\int_{\Omega}(\textbf{uold}.\triangledown)\textbf{uold}.\textbf{v}&=\frac{1}{\nu}\int_{\Omega}(\textbf{uold}.\triangledown)\textbf{uold}.\textbf{v} 
\end{array}
\]
Avec la condition de sortie $\color{blue}{-\int_{\partial\Omega} \bigtriangleup \textbf{u}.(\textbf{v}.\textbf{n})\text{d}\sigma}=\color{blue}{+\int_{\partial\Omega} p.(\textbf{v}.\textbf{n})\text{d}\sigma}$ il reste donc la formulation variationnelle pour une it√©ration : 
\[
\left\{
\begin{array}{rl}
\int_{\Omega} \triangledown \textbf{u}.\triangledown \textbf{v}
+\frac{1}{\nu}\int_{\Omega} [( \textbf{uold}. \triangledown) \textbf{u}+ (\textbf{u} .\triangledown) \textbf{uold}].\textbf{v} &\\ 

-\int_{\Omega} p\text{div}\textbf{v}
 
-\int_{\Omega} q\text{div}\textbf{u} &=

 \frac{1}{\nu}\int_{\Omega}(\textbf{uold}.\triangledown)\textbf{uold}.\textbf{v}\\
\textbf{u}_{|\Gamma_D}  &=g 
\end{array}
\right.
\]
Le dernier travail de l'√©tude num√©rique est donc d√©finir les espaces discrets. Soit le domaine de calcul $\Omega$, $\partial\Omega$ est la partie du bord de domaine dont la vitesse s'annule. Plusieurs choix sont possible, mais dans ce projet, on travail avec un exemple qui marche tr√®s bien dans ce cas, l'√©lement fini de type Taylor-Hood (P1-P2). On d√©finit les espaces :
\[
\begin{array}{rl}
X_h &= \left\{ \textbf{v}\in C^0(\overline{\Omega})^d; \textbf{v}_{|\kappa}\in \text{P}^d_2 \hspace{0.5cm} \forall \kappa \in T_h, \textbf{v}_{|\partial\Omega}=0 \right\}         \\

M_h &= \left\{ q\in C^0(\overline{\Omega});q_{|\kappa}\in \text{P}_1 \hspace{0.5cm} \forall \kappa \in T_h \right\}\cap\text{L}^2_0(\Omega) 
\end{array}
\]
\paragraph{Le probl√®me discret :}La question qui se pose dans le cadre discret est donc trouver $\left[\begin{array}{cc} \textbf{u}\\ p\end{array}\right] \in X_h \times M_h$ tels que $\forall \left[\begin{array}{cc} \textbf{v}\\ q\end{array}\right] \in X_h \times M_h$, on a : 

\[
\left\{
\begin{array}{rl}
\int_{\Omega} \triangledown \textbf{u}.\triangledown \textbf{v}
+\frac{1}{\nu}\int_{\Omega} [( \textbf{uold}. \triangledown) \textbf{u}+ (\textbf{u} .\triangledown) \textbf{uold}].\textbf{v} &\\ 

-\int_{\Omega} p\text{div}\textbf{v}
 
-\int_{\Omega} q\text{div}\textbf{u} &=

 \frac{1}{\nu}\int_{\Omega}(\textbf{uold}.\triangledown)\textbf{uold}.\textbf{v}\\
\textbf{u}_{|\Gamma_D}  &=g 
\end{array}
\right.
\]

\section{Reynold}
La r√©solution de l'√©quation de Navier-Stokes a √©t√© toujours difficile pour les nombres de Reynolds tr√®s grand, qui repr√©sente le rapport entre les forces d'inertie et les forces visqueuses. Si le nombre de Reynolds est tr√®s grand, l'√©quation devient fortement non-lin√©aire car les ph√©nom√®nes convectifs dominent. Les non-lin√©arit√©s produiront des effets instationnaires pour un for√ßage stationnaire, des brisures de sym√©tries par rapport aux conditions aux limites initiales, en d'autre termmes la turbulence, qui explose le syst√®me. 

La m√©thode adopte donc une strat√©gie qui r√©soud l'√©quation en auguementant le nombre de Reynolds petit √  petit. Soit la solution $\textbf{u}_{REY}$ correspond au nombre de Reynolds=REY, on r√©soud le syst√®me en retrouvant les solutions $\textbf{u}_{rey}$ correspond √  $rey < REY$, et puis on augemente $rey$ pour atteindre $REY$. L'algorithme est :
\[
\left\{
\begin{array}{lll}
\text{while } (rey<REY \hspace{0.25cm}) \\
\hspace{0.5cm} \{ \\
\hspace{1cm}\text{while }(\| \textbf{u}-\textbf{uold})\| \geqslant 10^{-6})\\
\hspace{1.5cm}\text{R√©soudre }\textbf{u}= \textbf{uold}-\text{dF}^{-1}_{\textbf{uold}}(\text{F}(\textbf{uold}));\\
\hspace{1cm}rey+=incrementRey; \\
\hspace{0.5cm} \} 
\end{array}
\right.
\]
Dans ce projet, particuli√®rement dans ce programme en C++ et son domaine de calcul (La marche descendante), la r√©solution peut atteindre Reynolds=1400 pour les auguementations de 50 ou 100, partant de Reynolds=1.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%=======================================================================================%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{√âtudes informatiques}
\section{Cr√©ation de maillage}
Comme pr√©sent√©, le domaine de calcul est une marche descendante de la forme :
%%%%%%%%%%%%%%%%%%%%%%%%%%  image Mesh%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{center}
\begin{pspicture}(-7,-1.5)(7,1.5)
\psline[linecolor=blue](5,1)(-5,1)%Label = 2
\rput(0,1.25){\Rnode{C}{\small{\color{blue}label=2}}}
\psline[linecolor=red](-5,1)(-5,0)%Label = 1
\rput(-5,1.25){\small $\beta$} \rput(-5,-0.25){\small $\alpha$}
\rput{90}(-5.25,0.5){\Rnode{D}{\small{\color{red}label=1}}}
\psline[linecolor=blue](-5,0)(-3,0)(-3,-1)(5,-1)%Label = 2
\rput(0,-1.25){\Rnode{E}{\small{\color{blue}label=2}}}
\pscurve[linecolor=green](5,-1)(4.75,-0.5)(5.1,0)(4.5,0.5)(5,1)%Label = 3
\rput{-90}(5.5,0){\Rnode{F}{\small{\color{green}label=3}}}


\pscurve[linecolor=red](-5,0)(-4,0.5)(-5,1)%Label = 3
\rput(-4.75,0.75){\Rnode{A}{}}
\rput(-6,1.5){\Rnode{B}{\color{red}\small 4*(y-$\alpha$)*($\beta$-y)}}
\ncline{->}{A}{B}

%\psline(-7,-1.5)(7,1.5)
\end{pspicture}
\end{center}
%%%%%%%%%%%%%%%%%%%%%%%%%%  image Mesh %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Les degr√© de libert√© setrouvant sur le label1 seront affect√©es par la condition de Dirichelet qui forme un profil parabolique de fluid entr√©. Sur le label2 la vitesse sera null. Sur le label3, les termes sont consid√©r√© comme l'int√©rieur du domaine (sont √  calculer).
\paragraph{Cr√©ation de Maillage : }
La cr√©ation de maillage se fait par Freefem++, en utilisant le script : CreatMesh.edp. Ce script lit les donn√©es dans le fichier MeshCorner.txt contenant les trois coins du maillage et un coeficient indiquant la densit√© de noeuds pour le maillage. En l'√©x√©cutant, il cr√©e un fichier MyMesh.msh contenant les donn√©es de maillage, fait une visualisation de maillage cr√©√©. 
\begin{lstlisting}
prompt$FreeFem++ CreatMesh.edp 
\end{lstlisting}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Conditions de bord}
La strat√©gie pour affecter la condition de Dirichelet au bord sur le label1 est :
\[
\left\|
\begin{array}{l}
\text{parcourir les arr√™tes au bord} \\
\hspace{0.2cm} \{ \\
\hspace{0.4cm} \text{Trouver l'√©l√©ment fini qui contient l'arr√™te;}\\
\hspace{0.4cm} \text{Parcourir les df locale} \\
\hspace{0.6cm} \{ \\
\hspace{0.8cm} \text{Si ((Label==1) et (df est sur l'arr√™te))} \\
\hspace{1cm}   \{ \\
\hspace{1.2cm}     \text{affecter la condition de bord au vecteur global;} \\
\hspace{1cm}   \} \\
\hspace{0.6cm} \} \\
\hspace{0.2cm} \}
\end{array}
\right.
\]
Donc l'impl√©mentation dans C++ est :
\begin{lstlisting}[language=C]
for (int ke=0;ke<Th.nbe;ke++){
 int kf,k=Th.BoundaryElement(ke,kf);
 FElement FK(Vh[k]);
 int nbdf=FK.NbDoF();
 int Label=Th.borderelements[ke].lab;
 for (int df =0;df<nbdf;++df){//condition Dirichelet
  if(((Element::onWhatBorder[kf][FK.DFOnWhat(df)])!=0)&&(Label==1)){
    int p=FK.DFOnWhat(df);Rd P(FK.pPi_h(p));
    dirichelet[FK(df)]=Poissieulle(P,FK.FromASubFE(df)); 
    }	
  }
}
\end{lstlisting}
Ensuite pour la r√©solution lin√©aire g√©n√©rale, on a une m√©thode de tr√®s grande valeur (TGV) servant √  r√©soudre le syst√®me de type Ax=b except√© de quelques points du vecteur x :
\[
\begin{array}{cc}
\left[
\begin{array}{lllll}
{\color{red}\bullet} & & & &\\
 & & & &\\
 & & & &\\
 & & &{\color{red}\bullet} &\\
 & & & &
\end{array}
\right]
\\
A
\end{array}
\begin{array}{cc}
\left[
\begin{array}{lllll}
{\color{blue}\bullet}\\
\\
\\
{\color{blue}\bullet}\\
\\
\end{array}
\right]
\\
x
\end{array}
=
\begin{array}{cc}
\left[
\begin{array}{lllll}
{\color{red}\bullet}\\
\\
\\
{\color{red}\bullet}\\
\\
\end{array}
\right]
\\
b
\end{array}
\]
Sur la matrice A, les points rouges sont sur la diagonale, de m√™me lignes que ceux du vecteur b. En mutipliant les points rouges par une valeur tr√®s tr√®s grande (de l'ordre de $10^{30}$) avant de r√©soudre le syst√®me, apr√®s la r√©solution, les points bleus prendront la m√™me valeur que les points rouge du vecteur b avant de mutiplication. L'impl√©mentation du code de cette m√©thode est suivant :
\begin{lstlisting}
for(int ke=0;ke<Th.nbe;++ke){	
 int kf,k=Th.BoundaryElement(ke,kf);
 FElement FK(Vh[k]);
 int ndf=FK.NbDoF();int Label=Th.borderelements[ke].lab;
  for (int df =0;df<ndf;++df){
  if (Element::onWhatBorder[kf][FK.DFOnWhat(df)] && (Label!=3)){
   if(FK.FromASubFE(df) < d){
    int i=FK(df);
    A[make_pair(i,i)] = tgv;
    b[i] = tgv*dirichelet[i];
    kkk++;
   }
  }
 }  
}
\end{lstlisting}
%%%%%%%%%%%%%%%%%%%%%%%%%% PASSAGE LOCAL-GLOBALE %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Passage Locale-Globale}
L'id√©e fondamentale du probl√®me est √  partir de la formulation variationnelle, on doit construire un syst√®me lin√©aire √  r√©soudre. La question est comment construire ce syst√®me lin√©aire dans le cadre g√©n√©ral. Cette question se pose sur un principe basique : le passage local-globale. Soit, l'espace fonctionnel discret $X_h \times M_h$ (FESpace) qui se construit par le maillage (Mesh) et le type d'√©l√©ment fini (TypeOfFE). Un FESpace se compose aussi des FElement, qui d√©crit toutes les donn√©es dans un √©l√©ment fini. Une fonction discr√®te dans FESpace est caract√©ris√©e par ses NBOFDF degr√© de libert√© (NBOFDF est le nombre de degr√©e de libert√© globale), localement, elle est caract√©ris√© par ses nbofdf degr√© de libert√© (nbofdf est le nombre de degr√© de libert√© locale). L'algorithme pour toute op√©ration sur les fonctions est dont de parcourir les FElement, effectuer les op√©rations sur les df locale, rassembler les r√©sultat par le passage ses df au DF (degr√© de libert√© global). En supposant que l'on a construit une matrice locale ML, le passage √  la matrice M globale se fait par :
\begin{lstlisting}
for(int i=0;i<nbDoF;i++)//Local==>GLOBALE 
  for(int j=0;j<nbDoF;j++) 
    M[make_pair<int,int>(FK(i),FK(j))] +=ML(i,j) ; 
\end{lstlisting}
Il en est de m√™me pour les vecteurs. Supposont que le vecteur local VL a √©t√© construit, le passage au vecteur b global se fait par :
\begin{lstlisting}
for(int idf=0;idf<nbDoF;idf++) 
  b[FK(idf)]+=VL[idf];
\end{lstlisting}
%%%%%%%%%%%%%%%%%%%%%%%%%% PASSAGE LOCAL-GLOBALE %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%% PASSAGE GLOBALE LOCALE%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Passage Global-Local}
Cette √©tape est necessaire dans le cas o√π le sch√©ma est it√©ratif, utilise les valeurs de la solution calcul√© de l'it√©ration pr√©c√©dante pour calculer la solution apr√®s. C'est l'√©tape sachant une fonction $UOLD$ calcul√©e, comment lire ces valeurs locales, afin de les passer dans le matrice A √  doite et le vecteur b √  gauche pour le syst√®me A.X=b. Les valeurs necessaires ne sont pas exactement les df de $UOLD$ au points d'interpolation, mais ce sont des valeurs de $UOLD$ aux points d'int√©gration. Pour chaque FElement, on doit donc parcourir les points d'int√©gration de la m√©thode d'int√©gration choisie, retrouver les valeurs necessaires de $UOLD$ sur ces points (valeurs de $UOLD$ et valeur de la d√©riv√©e de $UOLD$). Ces valeurs seront stoqu√©es dans un vecteur local $uold$
\begin{lstlisting}
for (int ipq=0;ipq<qf.n;ipq++){//qf.n=7
  /*======Les valeurs de UOLD local=====*/
 for(int ic=0;ic<d;ic++){ 
 uold(ic)=FK(qf[ipq],UOLD,ic,op_id);
   for(int ioperator=0;ioperator<d;ioperator++){
   Duold(ic,ioperator)=FK(qf[ipq],UOLD,ic,op_div[ioperator]);
   }	
 }	 
}
\end{lstlisting}
%%%%%%%%%%%%%%%%%%%%%%%%%% PASSAGE GLOBALE LOCALE%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


%%%%%%%%%%%%%%%%%%%%%%%%%% MATRICE LOCAL %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Matrice locale}
La construction de la matrice locale est fondamentale dans tout le programme. C'est cette √©tape qui impl√©mente le sch√©ma de l'algorithme math√©matique. Partant le la formulation variationnelle : 
\begin{equation}
\label{Formulation}
\begin{array}{rl}
\int_{\Omega} \triangledown \textbf{u}.\triangledown \textbf{v}
+\frac{1}{\nu}\int_{\Omega} [( \textbf{uold}. \triangledown) \textbf{u}+ (\textbf{u} .\triangledown) \textbf{uold}].\textbf{v} &\\ 

-\int_{\Omega} p\text{div}\textbf{v}
 
-\int_{\Omega} q\text{div}\textbf{u} &=

 \frac{1}{\nu}\int_{\Omega}(\textbf{uold}.\triangledown)\textbf{uold}.\textbf{v}
\end{array}
\end{equation}
On la d√©taille dans le cas 3D. Dans ce  cas, soit :
\[
\left[
\begin{array}{cc}
\textbf{u} \\
p
\end{array}
\right]
=
\left[
\begin{array}{cccc}
u1 \\
u2 \\
u3 \\
p
\end{array}
\right]
\hbox{,  }
\left[
\begin{array}{cc}
\textbf{v} \\
q
\end{array}
\right]
=
\left[
\begin{array}{cccc}
v1 \\
v2 \\
v3 \\
q
\end{array}
\right]
\hbox{,  }
\left[
\begin{array}{cc}
\textbf{uold} \\
pold
\end{array}
\right]
=
\left[
\begin{array}{cccc}
uold1 \\
uold2 \\
uold3 \\
pold
\end{array}
\right]
\]
La formulation ~\eqref{Formulation} d√©tall√©e dans le cas 3D sera :
%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\[
\begin{array}{l}
\int_{\Omega}\left[
\begin{array}{c}%Terme grad grad
 \frac{\partial u1}{\partial x}\frac{\partial v1}{\partial x}
+\frac{\partial u1}{\partial y}\frac{\partial v1}{\partial y}
+\frac{\partial u1}{\partial z}\frac{\partial v1}{\partial z} \\
 \frac{\partial u2}{\partial x}\frac{\partial v2}{\partial x}
+\frac{\partial u2}{\partial y}\frac{\partial v2}{\partial y}
+\frac{\partial u2}{\partial z}\frac{\partial v2}{\partial z} \\
 \frac{\partial u3}{\partial x}\frac{\partial v3}{\partial x}
+\frac{\partial u3}{\partial y}\frac{\partial v3}{\partial y}
+\frac{\partial u3}{\partial z}\frac{\partial v3}{\partial z} 
\end{array} \right] \\
+\frac{1}{\nu}\int_{\Omega}\left[
\begin{array}{c}
\left(\begin{array}{c}%terme nonlineaire1
uold1 \frac{\partial u1}{\partial x} v1  +
uold2 \frac{\partial u1}{\partial y} v1  +
uold3 \frac{\partial u1}{\partial z} v1  \\
uold1 \frac{\partial u2}{\partial x} v2  +
uold2 \frac{\partial u2}{\partial y} v2  +
uold3 \frac{\partial u2}{\partial z} v2  \\
uold1 \frac{\partial u3}{\partial x} v3  +
uold2 \frac{\partial u3}{\partial y} v3  +
uold3 \frac{\partial u3}{\partial z} v3  
\end{array}\right)
+
\left(\begin{array}{c}%terme nonlineaire2
u1v1 \frac{\partial uold1}{\partial x}  +
u2v1 \frac{\partial uold1}{\partial y}  +
u3v1 \frac{\partial uold1}{\partial z}  \\
u1v2 \frac{\partial uold2}{\partial x}  +
u2v2 \frac{\partial uold2}{\partial y}  +
u3v2 \frac{\partial uold2}{\partial z}  \\
u1v3 \frac{\partial uold3}{\partial x}  +
u2v3 \frac{\partial uold3}{\partial y}  +
u3v3 \frac{\partial uold3}{\partial z}   
\end{array}\right)
\end{array} \right] \\
-\int_{\Omega}\left[
\begin{array}{c}%pdivv
p\frac{\partial v1}{\partial x} \\
p\frac{\partial v2}{\partial y} \\
p\frac{\partial v3}{\partial z} 
\end{array} \right] \\
-\int_{\Omega}
\begin{array}{c}%qdivu
q\left[ \frac{\partial u1}{\partial x} +
 \frac{\partial u2}{\partial y} +
 \frac{\partial u3}{\partial z} 
 \right]
\end{array}  \\
=\frac{1}{\nu}\int_{\Omega}\left[
\begin{array}{c}%membre droit
uold1 \frac{\partial uold1}{\partial x} v1  +
uold2 \frac{\partial uold1}{\partial y} v1  +
uold3 \frac{\partial uold1}{\partial z} v1  \\
uold1 \frac{\partial uold2}{\partial x} v2  +
uold2 \frac{\partial uold2}{\partial y} v2  +
uold3 \frac{\partial uold2}{\partial z} v2  \\
uold1 \frac{\partial uold3}{\partial x} v3  +
uold2 \frac{\partial uold3}{\partial y} v3  +
uold3 \frac{\partial uold3}{\partial z} v3  
\end{array} \right] 
\end{array}
\]

A rappeler que dans ce cas, l'√©l√©ment fini utilis√© est de type Taylor-Hood (P1-P2), avec dimension 3D, chaque fonction se compose de 3 composantes de vitesse et une composante de presssion. Ce qui d√©coupe la matrice locale en bloque.  
\[
\left\|
\begin{array}{l}
\text{BOUCLE pour chaque FElement} \\
\text{Parcourir les points d'int√©gration} \\
\text{ Calcul des coef d'int√©gration;} \\
\text{ parcourir les composantes de la fonctions de solution}\\
\text{   parcourir les composantes de la fonctions de test}\\
\text{      parcourir les df de composante}\\
\text{          rajouter des coeufficients dans la matrice locale;} 
\end{array}
\right.
\]
Pour parcourir les points d'int√©grations :
\begin{lstlisting}
for (int ipq=0;ipq<qf.n;ipq++){//qf.n=7
 w=0.;uold=0.;Duold=0.;
 QuadraturePoint Pq(qf[ipq]);
 //les coef pour le schemas general
 R coefadvect= CADVECT*mes* Pq.a;
 R coefgradgrad = CGRADGRAD*mes*Pq.a;
 R coefqdivv = CQDIVV*mes*Pq.a;
 R coefpp =1e-10*mes*Pq.a;
 FK.BF(whatd, Pq,w); 
\end{lstlisting}
Calcul des valeurs locales de $uold$ :
\begin{lstlisting}
for(int ic=0;ic<d;ic++){ 
 uold(ic)=FK(qf[ipq],UOLD,ic,op_id);
 for(int ioperator=0;ioperator<d;ioperator++){
 Duold(ic,ioperator)= FK(qf[ipq],UOLD,ic,op_div[ioperator]);
 }	
}	  
\end{lstlisting}
et pour parcourir les composantes des fonctions et ses df :
\begin{lstlisting}
for(int ic=0;ic<d;ic++){//ic=composante v.
  for(int jc=0;jc<d;jc++){//jc=composante u
  int idfbegin=FK.dfcbegin(ic); int idfend=FK.dfcend(ic); 
  int jdfbegin=FK.dfcbegin(jc); int jdfend=FK.dfcend(jc); 
  ........
\end{lstlisting}
%%%%%%%%%%%%%%%%%%%%%%%%%% MATRICE LOCAL %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%% PASSAGE AU MEMBRE DROITE %%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Passage au membre droite}
Dans les cas des sch√©mas it√©ratif, le passage de la solution calcul√©e au memebre √  droite est aussi important et se fait de fa√ßon similaire que la construction de la matrice du syst√®me A.x=b. Comme la construction de la matrice du syst√®me, ce passage necessite en premier la construction locale des valeurs de la fonctions calcul√©e aux points d'int√©grations. La construction locale se fait en premier par parcourir localement les composantes de la fonction, puis parcourir les df locales de cette composante : 
\begin{lstlisting}
for(int ic=0;ic<d;++ic){
int dfbegin=FK.dfcbegin(ic),dfend=FK.dfcend(ic);
 for(int i=dfbegin;i<dfend;i++){
   for(int i_derivate=0;i_derivate<d;i_derivate++){
      //(uold.grad)uold.vi
      VL[i] +=coefadvec*uold(i_derivate)
              *Duold(ic,i_derivate)*w(i,ic,op_id);
   }
 }
}
\end{lstlisting}
Apr√®s chaque calcul local, il ne reste √  faire l'impl√©ment dans le vecteur global :
\begin{lstlisting}
..........
   for(int idf=0;idf<nbDoF;idf++) 
      b[FK(idf)]+=VL[idf];
............
\end{lstlisting}
%%%%%%%%%%%%%%%%%%%%%%%% PASSAGE AU MEMBRE DROITE %%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%STRUCTURE ET UTILISATION %%%%%%%%%%%%%%%%%%
\section{Structure du programme et utilisation}
Les programmes de calcul est cod√© en C++. Quelques script de FreeFem++ sont programm√©s aussi utilisant le m√™me algorithme math√©matique, afin de comparer la solution Cpp-FFpp pour une validation sure des calcul C++.

A remarquer que les script FreeFem++ ne prend pas d'argument, on doit donc cr√©er les fichiers de texte .txt qui ont pour r√¥le stoquer les donn√©es communes pour tous les calcul. 
\begin{itemize}
 \item MeshCorner.txt : contient les donn√©e pour cr√©er le maillage.
 \item CoefSchemas.txt :contient le nombre Reynolds et sont incr√©mentation 
 \item nameMesh.txt : Dans le cas o√π plusieurs maillage existe, un seul peut √™tre utilis√© pour les calculs, le fichier nameMesh.txt contient le nom du fichier maillage qui sera utilis√© pour le calcul.
\end{itemize}
Pour les scripts de FreeFem++
\begin{itemize}
 \item CreatMesh.edp : lit les donn√©es dans MeshCorner.txt (3 coins et la densit√© des noeuds)pour cr√©er le maillage
 \item NSstatNCT.edp : lit les donn√©es dans MeshCorner.txt, CoefSchemas.txt,nameMesh.txt pour calculer la solution de Navier-Stokes. La solution est stoqu√©e dans NSsFFpp.sol
 \item StokesNCT.edp : lit les donn√©es dans MeshCorner.txt, CoefSchemas.txt,nameMesh.txt pour calculer la solution de Stokes. La solution est stoqu√©e dans Stokes.sol
\end{itemize}
\begin{lstlisting}
FreeFem++ CreatMesh.edp 
FreeFem++ NSstatNCT.edp 
FreeFem++ StokesNCT.edp  
\end{lstlisting}
Pour les programme C++ :
\begin{itemize}
 \item NavierStokes [meshfile] : Calcule la solution de Navier-Stokes en sortant le r√©sultat dans NSsCpp.sol. Les valeurs pour visualiser la condition de bord Dirichelet est stoqu√©e dans NSsDiriCpp.sol
 \item Stokes [meshfile] : Calcule la solution de Stokes en sortant le r√©sultat dans StokesCpp.sol. Les valeurs pour visualiser la condition de bord Dirichelet est stoqu√©e dans StokesDiriCpp.sol
 \item Visualization [Sol1] [Sol2] : cr√©e un script de FF++ pour visualiser les solutions, leur diff√©rence. l'argument Sol2 est facultative. 
 \item GUI\_NS : fait tout dans un GUI.
\end{itemize}
\begin{lstlisting}
Prompt$ ./NavierStokes MyMesh.msh
Prompt$ ./Stokes MyMesh.msh
Prompt$ ./Visualization NSsDiriCpp.sol
Prompt$ ./Visualization NSsCpp.sol NSsFFpp.sol
Prompt$ ./GUI\_NS
\end{lstlisting}
Voici un tableau d√©crit les interactions entres les fichiers et les programmes :
\begin{center}
\begin{tabular}{|p{3cm}|c|p{3cm}|}
 \hline
\textbf{Fichier √  lire}&\textbf{Programme} &\textbf{Fichiers sorties} \\  \hline
MeshCorner.txt & CreatMesh.edp & MyMesh.msh\\  \hline
MeshCorner.txt, CoefSchemas.txt, nameMesh.txt & NSstatNCT.edp & NSsFFpp.sol \\  \hline
MeshCorner.txt, CoefSchemas.txt, nameMesh.txt & StokesNCT.edp & StokesFFpp.sol \\  \hline
*.msh           &./NavierStokes   & NSsDiriCpp.sol, NSsCpp.sol \\  \hline
*.msh           & ./Stokes        & StokesDiriCpp.sol, StokesCpp.sol \\  \hline
*.sol1 [*.sol2] & ./Visualization & \\  \hline
*.txt           & ./GUI$\_$NS       & *.txt\\  \hline
\end{tabular}
\end{center}
\section{R√©sultats en image }
Voici les images solutions de C++, FF++ et la diff√©rence des deux solutions :
\begin{center}
\begin{figure}[h]
 \centering
 \includegraphics[scale=0.30]{Sol1}
 \caption{Solution C++}
\end{figure}
\end{center}

\begin{center}
\begin{figure}[h]
 \centering
 \includegraphics[scale=0.30]{Sol2}
 \caption{Solution FF++}
\end{figure}
\end{center}

\begin{center}
\begin{figure}[h]
 \centering
 \includegraphics[scale=0.30]{Erreur}
 \caption{Diff√©rence C++ FF++}
\end{figure}
\end{center} 
%%%%%%%%%%%%%%%%%%%%%STRUCTURE ET UTILISATION %%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%=======================================================================================%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Qt Programmation GUI}
Qt est un framework C++ permettant de d√©velopper des applications GUI multiplates-formes. Qt permet aux programmeurs d'employer une seule arborescence source pour des application qui s'√©x√©cuteront sous Windows, Mac OS X, Linux et de nombreuses autres versions d'Unix avec X11. Les biblioth√®ques et outils Qt font √©galement partie de Qtopia Core. J'ai l'id√©e de programmation Qt quand je suis tomb√© sur le siteweb :
\begin{itemize}
 \item Introduction : \href{http://www.siteduzero.com/tutoriel-3-11240-introduction-a-qt.html}{http://www.siteduzero.com/tutoriel-3-11240-introduction-a-qt.html}
\end{itemize}
qui est une tr√®s bonne introduction √  la programmation Qt. Ensuite, on peut consulter les sites officiels pour une pratique et compr√©hension plus approfondie :
\begin{itemize}
 \item Documentation [fr] : \href{http://doc.qtfr.org/}{http://doc.qtfr.org/}
 \item Documentation [en] : \href{http://doc.trolltech.com/}{http://doc.trolltech.com/}
\end{itemize}
Pour apprendre Qt, j'ai consult√© en premier l'introduction sur le siteduz√©ro pour comprendre la compilation, l'installation de Qt. Ensuite, je suis parti sur le site officielle pour t√©l√©charger les exemples, les compiler et les corriger pour approfondir. Pour une lecture plus structur√©e, on pourra consulter \cite{NCT7}
%%%%%%%%%%%%%%%%%%%%%%% PR√âSENTATION GUI_NS %%%%%%%%%%%%%%%%%%%%%%%%%%%%% 
\section{Pr√©sentation du GUI\_NS}
Mon programme GUI\_NS se compose principalement des objets QLineEdit, QPushButton, QProcess. Les QLineEdit permet de saisir un texte, c'est l√  que l'utilisateur fait entrer ses donn√©es d√©sir√©es. QPushButton est simplement un ... bouton. QProcess est comme un processu, fait tourner des programmes ext√©rieurs. Le m√©canisme g√©n√©ral est √  chaque fois qu'on presse sur un Bouton, il √©met un signal, qui fait appel √  \"quelques choses\".Celles-ci peut √™tre d'appel une fonction, d√©marrer un processu, d√©clencher le chronom√®tre, lire les donn√©es dans les champs, √©crire les donn√©es dans les champs, dans les fichiers..ect...Ce m√©canisme se r√©alise gr√¢ce √  la m√©thode statique  QObject::connect(Objet1,SIGNAL(...),Objet2,SLOT(...)). 
\paragraph{Fenetre Creat Mesh :} 
\begin{center}
\begin{figure}[h]
 \includegraphics[scale=0.60]{CreatMesh}
 \caption{F√™netre Creat Mesh} 
\end{figure}
\end{center}
Dans cette fenetre, on a la connection :
\begin{lstlisting}
  QObject::connect(button_CreatMesh,SIGNAL(clicked()),
                   this,SLOT(CreatMeshSLOT()));
\end{lstlisting}
qui fait que si je clike sur le bouton CreatMesh, la fonction sp√©ciale (SLOT) CreatMeshSLOT() sera appel√©e, elle lit les donn√©es dans les champs saisies, les √©crit dans le fichier MeshCorner.txt, appelle le script CreatMesh.edp :
\begin{lstlisting}
void  CreatMeshTab::CreatMeshSLOT(){
  system("rm -f *.msh");
  double a1x_value=LineEdita1x->text().toDouble();
  double a1y_value=LineEdita1y->text().toDouble();
  double a2x_value=LineEdita2x->text().toDouble();
  double a2y_value=LineEdita2y->text().toDouble();
  double a3x_value=LineEdita3x->text().toDouble();
  double a3y_value=LineEdita3y->text().toDouble();
  int Coefdense_value=LineEditCoefdense->text().toInt();
  {
    ofstream fileout("MeshCorner.txt");
    fileout<<a1x_value<<" "<<a1y_value<<endl
	   <<a2x_value<<" "<<a2y_value<<endl
	   <<a3x_value<<" "<<a3y_value<<endl
	   <<Coefdense_value<<endl;
  }
  system("FreeFem++ CreatMesh.edp");
  char commandeSaveMesh[256];
  strcpy(commandeSaveMesh,"mv MyMesh.msh ");
  strcat(commandeSaveMesh,
        LineEditNameMeshSave->text().toStdString().c_str());
  system(commandeSaveMesh);
  //cout<<commandeSaveMesh<<endl;
} 
\end{lstlisting}
\paragraph{Fenetre Coef Schemas :}
\begin{center}
\begin{figure}[h]
 \includegraphics[scale=0.50]{CoefSchema}
 \caption{F√™netre Coef Sch√©ma} 
\end{figure}
\end{center}
De m√™me, la fenetre Coef Sch√©ma a pour connection :
\begin{lstlisting}
QObject::connect(button_SetCoef,SIGNAL(clicked()),
                 this,SLOT(SetCoefSLOT())); 
\end{lstlisting}
En appuyant sur le bouton \textbf{Set Coef}, on √©crit ces donn√©es dans le fichier CoefSchemas.txt et modifie les donn√©es dans la fenetre Run.
\paragraph{Fenetre Run :}
\begin{center}
\begin{figure}[h]
 \includegraphics[scale=0.50]{Run}
 \caption{F√™netre Run} 
\end{figure}
\end{center}
La fenetre Run est la plus compliqu√©e, contient :
\begin{lstlisting}
QObject::connect(TimerChronoCpp,SIGNAL(timeout()),
                 this,SLOT(UpdateTimeCppSLOT()));
QObject::connect(TimerChronoFFpp,SIGNAL(timeout()),
                 this,SLOT(UpdateTimeFFppSLOT()));
QObject::connect(RunProcess,SIGNAL(finished(int,QProcess::ExitStatus)),
                 TimerChronoCpp,SLOT(stop()));
QObject::connect(RunProcess,SIGNAL(finished(int,QProcess::ExitStatus)),
                 TimerChronoFFpp,SLOT(stop()));
QObject::connect(button_LoadMesh,SIGNAL(clicked()),
                 this,SLOT(LoadMeshSLOT()));
QObject::connect(button_RunCpp,SIGNAL(clicked()),
                 RunProcess,SLOT(kill()));
QObject::connect(button_RunCpp,SIGNAL(clicked()),
                 this,SLOT(RunCppSLOT()));
QObject::connect(button_RunFFpp,SIGNAL(clicked()),
                 RunProcess,SLOT(kill()));
QObject::connect(button_RunFFpp,SIGNAL(clicked()),
                 this,SLOT(RunFFppSLOT()));
QObject::connect(button_Break,SIGNAL(clicked()),
                 RunProcess,SLOT(kill()));
QObject::connect(button_Break,SIGNAL(clicked()),
                 this,SLOT(ResetTimeSLOT()));
\end{lstlisting}
Le bouton \textbf{Load Mesh} recherche le fichier de maillage, modifie le text dans le champs Mesh file. Le bouton \textbf{Run C++} appelle le programme C++, d√©clanche le chronom√®tre Cpp. Le bouton \textbf{Run FreeFem++} appelle le programme FF++, d√©clanche le chronom√®tre FFpp. Le bouton \textbf{Break} arr√™te tout programme de fa√ßon brutale et remet le chronom√®tre √  z√©ro.
\paragraph{Fenetre Visualization :}
\begin{center}
\begin{figure}[h]
 \includegraphics[scale=0.50]{Visualization}
 \caption{Fenetre Visualisation} 
\end{figure}
\end{center}
Cette f√™netre est aussi simple que la fenetre Coef Sch√©ma, qui lit les fichiers de solution, appelle le programme C++ ./visualisation (qui cr√©e encore un script FreeFem++) pour visualiser les solutions. Le bouton \textbf{Load Sol1} recherche la premi√®re solution √  visualiser. Le bouton \textbf{Load Sol2} recherche la deuxi√®me solution √  visualiser. Le bouton \textbf{Visualization} appelle le programme :
\begin{lstlisting}
Prompt$ ./Visualization First.sol Second.sol 
\end{lstlisting}
Si on ne met rien dans le champs saisie de la deuxi√®me solution, \textbf{Visualization} appelle :
\begin{lstlisting}
Prompt$ ./Visualization First.sol 
\end{lstlisting}
\begin{lstlisting}
QObject::connect(button_LoadSol1,SIGNAL(clicked()),
                 this,SLOT(LoadSol1SLOT()));
QObject::connect(button_LoadSol2,SIGNAL(clicked()),
                 this,SLOT(LoadSol2SLOT()));
QObject::connect(button_Visualization,SIGNAL(clicked()),
                 this,SLOT(VisualizationSLOT()));
\end{lstlisting}
\paragraph{Remarque sur QProcess:}
Quelques SLOT fait appel aux programme externe sous forme processu. Pour ne pas s'occuper des iostandard du programme externe, il faut le regler en mode sp√©cifique utilisant la fonction setProcessChannelMode(mode) de la classe QProcess.
\begin{lstlisting}
Process::setProcessChannelMode(QProcess::ForwardedChannels);
\end{lstlisting}
\paragraph{Remarque sur QTime et QTimer:}
Pour la construction de l'horloge de calcul, il faut deux objets qui se ressemble en notation QTime et QTimer. Ces deux objets sont utilis√© pour de buts diff√©rents QTime s'utilise comme une horloge, tandis que QTimer s'utiliser comme un chronom√®tre :
\begin{lstlisting}
QTime *Chronometre;QTime *TempsCalcul;
QTimer *TimerChronoCpp;QTimer *TimerChronoFFpp;
\end{lstlisting}
TimerChronoCpp, TimerChronoFFpp sont utilis√©s pour chronom√®trer les dur√©es de calcul respectivement de C++ et FF++. Ensuite, en utilisant la fonction de QTime::elapsed(), on peut calculer le temps √©coul√© souhait√©.
%%%%%%%%%%%%%%%%%%%%%%% PR√âSENTATION GUI_NS %%%%%%%%%%%%%%%%%%%%%%%%%%%%% 

%%%%%%%%%%%%%%%%%%%%%%% Utilisation GUI_NS %%%%%%%%%%%%%%%%%%%%%%%%%%%%% 
\section{Utilisation}
La complilation est assez compliqu√©e utilisant un outil sp√©cifique : qmake. Cet outil g√©n√®re automatiquement le fichier Makefile pour le projet. Pour cette raison, il faut mettre le programme dans un directoire diff√©rent que le projet principale, le compiler, et l'amener dans le projet apr√®s la compilation pour l'utiliser. 
%%%%%%%%%%%%%%%%%%%%%%% Utilisation GUI_NS %%%%%%%%%%%%%%%%%%%%%%%%%%%%% 





\bibliography{ReferenceNCT}
\nocite{*}
\end{document}



